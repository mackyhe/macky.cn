<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenFeign调用详解[Spring Cloud Hoxton.SR*版本]</title>
      <link href="/2022/03/18/openFeign/index/"/>
      <url>/2022/03/18/openFeign/index/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Feign是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p><h3 id="Feign能干什么？">Feign能干什么？</h3><p>Feign旨在是编写Java Http客户端变得更加容易。<br>但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端来包装这些依赖服务的调用。所以Feign在此基础上做了进一步封装，由它来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。</p><p>Feign集成了Ribbon, 利用Ribbon维护了Payment的服务列表信息，并且通过轮训实现了客户端的负载均衡。而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</p><h2 id="OpenFeign使用详解">OpenFeign使用详解</h2><h3 id="pom-xml添加依赖：spring-cloud-starter-openfeign">pom.xml添加依赖：spring-cloud-starter-openfeign</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud2020<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.macky.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud-consumer-feign-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.macky.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml配置文件">application.yml配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://springcloud-eureka7001.com:7001/eureka/,http://springcloud-eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="启动类加上-EnableFeignClients注解开启Feign功能">启动类加上@EnableFeignClients注解开启Feign功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.macky.springcloud;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//开启Feign远程服务调用功能</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignOrderServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(FeignOrderServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明FeignClient">声明FeignClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.macky.springcloud.feign;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> cn.macky.springcloud.common.JsonResult;</span><br><span class="line"><span class="keyword">import</span> cn.macky.springcloud.entity.Payment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Feign接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Macky.He</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> * Feign是一个interface接口</span></span><br><span class="line"><span class="comment"> * Feign的实现的过程大致如下：</span></span><br><span class="line"><span class="comment"> * a. 首先通过<span class="doctag">@EnableFeignClients</span>注解开启FeignClient</span></span><br><span class="line"><span class="comment"> * b. 根据Feign的规则实现接口，并加<span class="doctag">@FeignClient</span>注解</span></span><br><span class="line"><span class="comment"> * c. 程序启动后，会进行包扫描，扫描所有的@ FeignClient的注解的类，并将这些信息注入到ioc容器中。</span></span><br><span class="line"><span class="comment"> * d. 当接口的方法被调用，通过jdk的代理，来生成具体的RequestTemplate</span></span><br><span class="line"><span class="comment"> * e. RequestTemplate在生成Request</span></span><br><span class="line"><span class="comment"> * f. Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</span></span><br><span class="line"><span class="comment"> * g. 最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@FeignClient注解value属性指定Payment服务注册到Eureka上的ApplicationName</span></span><br><span class="line"><span class="comment">//@FeignClient注解fallback属性指定失败回调</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;SPRINGCLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentServiceFeignClient</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    JsonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Controller增加测试方法">Controller增加测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.macky.springcloud.controller;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> cn.macky.springcloud.common.JsonResult;</span><br><span class="line"><span class="keyword">import</span> cn.macky.springcloud.entity.Payment;</span><br><span class="line"><span class="keyword">import</span> cn.macky.springcloud.feign.PaymentServiceFeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Feign控制层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Macky.He</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentServiceFeignClient paymentServiceFeignClient;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/openfeign/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentServiceFeignClient.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试">测试</h3><p>启动Eureka集群，服务提供者PaymentService集群以及Feign客户端，浏览器访问多次：<a href="http://localhost/openfeign/consumer/payment/get/3">http://localhost/openfeign/consumer/payment/get/3</a></p><h2 id="OpenFeign超时控制">OpenFeign超时控制</h2><p>默认Feign客户端只等待一秒钟，但是服务端处理需要超过一秒钟，导致Feign客户端不想等待了，直接返回报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。下面先模拟一下超时报错：</p><h3 id="在服务提供者Controller添加如下方法：">在服务提供者Controller添加如下方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 业务逻辑处理正确，但是需要耗费3秒钟</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PaymentServiceFeignClient中增加一个方法">PaymentServiceFeignClient中增加一个方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="Feign客户端Controller中加入如下方法">Feign客户端Controller中加入如下方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/openfeign/consumer/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">paymentFeignTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// OpenFeign客户端一般默认等待1秒钟</span></span><br><span class="line">    <span class="keyword">return</span> paymentServiceFeignClient.paymentFeignTimeout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2">测试</h3><p>浏览器访问http://localhost/openfeign/consumer/payment/feign/timeout，发现报如下图错误：<br><img src="https://img-blog.csdnimg.cn/20200816085600372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dlaXhpYW9odWFp,size_16,color_FFFFFF,t_70" alt="img"></p><p>这就是Feign默认只等待一秒钟，但是我们服务提供者业务处理需要三秒钟，这样肯定就会超时。</p><h3 id="解决方法">解决方法</h3><p>在application.yml配置文件中配置ribbon的超时时间控制</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置feign客户端超时时间(OpenFeign默认支持ribbon)  OpenFeign客户端一般默认等待1秒钟</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>上述配置表示Feign愿意等待五秒钟，业务处理需要三秒钟，那么这样就不会出现Read Timeout错误。重启Feign客户端，重新访问 <a href="http://localhost/openfeign/consumer/payment/feign/timeout%EF%BC%8C%E5%8F%91%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%88%90%E5%8A%9F%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">http://localhost/openfeign/consumer/payment/feign/timeout，发现接口成功返回数据，如下图所示：</a><br><img src="https://img-blog.csdnimg.cn/20200816090019162.png" alt="img"></p><h2 id="OpenFeign日志增强">OpenFeign日志增强</h2><p>有时候，在项目中可能会频繁使用Feign跨服务调用，而我们在开发的时候可能需要详细了解具体的传参、请求头信息等，这个时候我们可以对Feign的日志进行增强。</p><p>Feign的日志级别主要有四种：</p><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、响应状态码以及执行时间；</li><li>HEADERS：处理BASIC中定义的信息外，还有请求和响应头信息；</li><li>FULL：处理HEADERS中定义的信息之外，还有请求和响应的正文以及元数据信息；</li></ul><p>详细的配置过程主要有两步：</p><h3 id="Feign日志增强配置">Feign日志增强配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.macky.springcloud.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> Feign日志增强配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Macky.He</span></span><br><span class="line"><span class="comment"> * 说明:</span></span><br><span class="line"><span class="comment"> * Feign的日志级别主要有四种：</span></span><br><span class="line"><span class="comment"> * NONE：默认的，不显示任何日志；</span></span><br><span class="line"><span class="comment"> * BASIC：仅记录请求方法、URL、响应状态码以及执行时间；</span></span><br><span class="line"><span class="comment"> * HEADERS：处理BASIC中定义的信息外，还有请求和响应头信息；</span></span><br><span class="line"><span class="comment"> * FULL：处理HEADERS中定义的信息之外，还有请求和响应的正文以及元数据信息；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignLogConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">logLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="application-yml中声明Feign接口的日志级别">application.yml中声明Feign接口的日志级别</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#以debug日志级别监控PaymentServiceFeignClient这个接口</span></span><br><span class="line">    <span class="attr">cn.macky.springcloud.feign.PaymentServiceFeignClient:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>重启Feign客户端，浏览器访问：<a href="http://localhost/openfeign/consumer/payment/get/3">http://localhost/openfeign/consumer/payment/get/3</a></p><p>观察后台日志，可见，整个Feign调用的所有请求头、请求参数等都详细输出到日志中，这对于我们排查问题有很大的帮助。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2020-08-16 09:15:08.144 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] &lt;--- HTTP/1.1 200 (2506ms)</span><br><span class="line">2020-08-16 09:15:08.145 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] connection: keep-alive</span><br><span class="line">2020-08-16 09:15:08.145 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] content-type: application/json</span><br><span class="line">2020-08-16 09:15:08.145 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] date: Sun, 16 Aug 2020 01:15:08 GMT</span><br><span class="line">2020-08-16 09:15:08.145 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] keep-alive: timeout=60</span><br><span class="line">2020-08-16 09:15:08.146 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] transfer-encoding: chunked</span><br><span class="line">2020-08-16 09:15:08.146 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] </span><br><span class="line">2020-08-16 09:15:08.149 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] &#123;&quot;code&quot;:200,&quot;msg&quot;:&quot;查询成功,serverPort:  8002&quot;,&quot;data&quot;:&#123;&quot;pkid&quot;:3,&quot;serial&quot;:&quot;2020072503&quot;&#125;&#125;</span><br><span class="line">2020-08-16 09:15:08.150 DEBUG 10516 --- [p-nio-80-exec-4] c.m.s.feign.PaymentServiceFeignClient    : [PaymentServiceFeignClient#getPaymentById] &lt;--- END HTTP (91-byte body)</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>Feign的实现的过程大致如下：</p><ul><li>首先通过@EnableFeignCleints注解开启FeignCleint</li><li>根据Feign的规则实现接口，并加@FeignCleint注解</li><li>程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。</li><li>当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate</li><li>RequesTemplate在生成Request</li><li>Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</li><li>最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单表数据量大一定要分库分表吗？</title>
      <link href="/2022/03/18/sql/index/"/>
      <url>/2022/03/18/sql/index/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述">1. 概述</h2><p>在业务发展初期单表完全可以满足业务需求，在阿里巴巴开发手册也建议：单表行数超过500万行或者单表容量超过2GB才推荐进行分库分表，如果预计三年后数据量根本达不到这个级别，请不要在创建表时就分库分表。</p><p>但是随着业务的发展和深入，单表数据量不断增加，逐渐成为业务系统的瓶颈。这是为什么呢？</p><p>从宏观层面分析任何物体都必然有其物理极限。1965年英特尔创始人摩尔预测：集成电路上可容纳的元器件的数目，约每隔24个月增加一倍，性能提升一倍，即计算机性能每两年翻一番。</p><p>但是摩尔定律会有终点吗？有些科学家认为摩尔定律是有终点的：半导体芯片单位面积可集成的元件数量是有极限的，因为半导体芯片制程工艺的物理极限为2到3纳米。当然也有科学家不支持这种说法，但是我们可以从中看出物理极限是很难突破的，当单表数据量达到一定规模时必然也达到极限。</p><p>从细节层面分析我们将数据保存在数据库，实际上是保存在磁盘中，一次磁盘IO操作需要经历寻道、旋转延时、数据传输三个步骤，那么一次磁盘IO耗时公式如下：</p><blockquote><p>单次IO时间 = 寻道时间 + 旋转延迟 + 传送时间</p></blockquote><p>总体来说上述操作都较为耗时，速度和内存相比有着数量级的差距，当数据量过大磁盘这一瓶颈更加明显。那么应该怎么办？处理单表数据量过大有以下六字口诀：删、换、分、拆、异、热。</p><p><img src="http://img.macky.cn/content/2022-03-18/1.jpg" alt="img"></p><p>删是指删除历史数据并进行归档。换是指不要只使用数据库资源，有些数据可以存储至其它替代资源。分是指读写分离，增加多个读实例应对读多写少的互联网场景。拆是指分库分表，将数据分散至不同的库表中减轻压力。异指数据异构，将一份数据根据不同业务需求保存多份。热是指热点数据，这是一个非常值得注意的问题。</p><h2 id="2-删">2. 删</h2><p>我们分析这样一个场景：消费者会经常查询一年之前的订单记录吗？答案是一般不会，或者说这种查询需求量很小。根据上述分析那么一年前的数据我们就没有必要放在单表这张业务主表，可以将一年前的数据迁移到历史归档表。</p><p><img src="http://img.macky.cn/content/2022-03-18/2.jpg" alt="img"></p><p>在查询历史数据表时，可以限制查询条件如必须选择日期范围，日期范围不能超过X个月等等从而减轻查询压力。</p><p>处理历史存量数据比较简单，因为存量数据一般是静态的，此时状态已经不再改变了。数据处理一般分为以下两个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) 迁移一年前数据至历史归档表</span><br><span class="line">(2) 根据主键分批删除主表数据</span><br></pre></td></tr></table></figure><p>不能一次性删除所有数据，因为数据量太大可能会引发超时，而是应该根据ID分批删除，例如每次删除500条数据。</p><p>第一步查询一年前主键最大值和最小值，这是我们需要删除的数据范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">MIN</span>(id) <span class="keyword">AS</span> minId, </span><br><span class="line"><span class="built_in">MAX</span>(id) <span class="keyword">AS</span> maxId </span><br><span class="line"><span class="keyword">FROM</span> biz_table </span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="operator">&lt;</span> DATE_SUB(now(),<span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>)</span><br></pre></td></tr></table></figure><p>第二步删除数据时不能一次性全部删掉，因为很可能会超时，我们可以通过代码动态更新endId进行批量删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> biz_table </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> #&#123;minId&#125;</span><br><span class="line"><span class="keyword">AND</span> id <span class="operator">&lt;=</span> #&#123;maxId&#125;</span><br><span class="line"><span class="keyword">AND</span> id <span class="operator">&lt;=</span> #&#123;endId&#125;</span><br><span class="line">LIMIT <span class="number">500</span></span><br></pre></td></tr></table></figure><h2 id="3-换">3. 换</h2><p>换是指换一个存储介质，当然并不是说完全替换，而是用其它存储介质对数据库做一个补充。例如海量流水记录，这类数据量级是巨量的，根本不适合存储在MySQL数据库中，那么这些数据可以存在哪里呢？</p><p>现在互联网公司一般都具备与之规模相对应的大数据服务或者平台，那么作为业务开发者要善于应用公司大数据能力，减轻业务数据库压力。</p><h3 id="3-1-消息队列">3.1. 消息队列</h3><p>这些海量数据可以存储至Kafka，因为其本质上就是分布式的流数据存储系统。使用Kafka有如下优点：</p><p>第一个优点是Kafka社区活跃功能强大，已经成为了一种事实上的工业标准。大数据很多组件都提供了Kafka接入组件，经过生产验证并且对接成本较小，可以为下游业务提供更多选择。</p><p>第二个优点是Kafka具有消息队列本身的优点例如解耦、异步和削峰。</p><p><img src="http://img.macky.cn/content/2022-03-18/3.png" alt="img"></p><p>假设这些海量数据都已经存储在Kafka，现在我们希望这些数据可以产生业务价值，这涉及到两种数据分析任务：离线任务和实时任务。</p><p>离线任务对实时性要求不高，例如每天、每周、每月的数据报表统计分析，我们可以使用基于MapReduce数据仓库工具Hive进行报表统计。</p><p>实时任务对实时性要求高，例如根据用户相关行为推荐用户感兴趣的商品，提高用户购买体验和效率，可以使用Flink进行流处理分析。例如运营后台查询分析，可以将数据同步至ES进行检索。</p><p>还有一种分类方式是将任务分为批处理任务和流处理任务，我们可以这么理解：离线任务一般使用批处理技术，实时任务一般使用流处理技术。</p><h3 id="3-2-API">3.2. API</h3><p>上一个章节我们使用了Kafka进行海量数据存储，由于其强大兼容性和集成度，可以作为数据中介将数据进行中转和解耦。</p><p>当然我们并不是必须使用Kafka进行中转，例如我们直接可以使用相关Java API将数据存入Hive、ES、HBASE等。</p><p>但是我并不推荐这种做法，因为将保存流水这样操作耦合进业务代码并不合适，违反了高内聚低耦合的原则，尽量不要使用。</p><h3 id="3-3-缓存">3.3. 缓存</h3><p>从广义上理解换这个字，我们还可以引入Redis远程缓存，把Redis放在MySQL前面，拦下一些高频读请求，但是要注意缓存穿透和击穿问题。</p><p>缓存穿透和击穿从最终结果上来说都是流量绕过缓存打到了数据库，可能会导致数据库挂掉或者系统雪崩，但是仔细区分还是有一些不同，我们分析一张业务读取缓存一般流程图。</p><p><img src="http://img.macky.cn/content/2022-03-18/4.jpg" alt="img"></p><p>我们用文字简要描述这张图：</p><p>(1) 业务查询数据时首先查询缓存，如果缓存存在数据则返回，流程结束<br>(2) 如果缓存不存在数据则查询数据库，如果数据库不存在数据则返回空数据，流程结束<br>(3) 如果数据库存在数据则将数据写入缓存并返回数据给业务，流程结束<br>假设业务方要查询A数据，缓存穿透是指数据库根本不存在A数据，所以根本没有数据可以写入缓存，导致缓存层失去意义，大量请求会频繁访问数据库。</p><p>缓存击穿是指请求在查询数据库前，首先查缓存看看是否存在，这是没有问题的。但是并发量太大，导致第一个请求还没有来得及将数据写入缓存，后续大量请求已经开始访问缓存，这是数据在缓存中还是不存在的，所以瞬时大量请求会打到数据库。</p><p>我们可以使用分布式锁加上自旋解决这个问题，本文给出一段示例代码，具体原理和代码实现请参看我之前的文章：流程图+源码深入分析：缓存穿透和击穿问题原理以及解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务回调</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 今日头条号「JAVA前线」</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RedisBizCall</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后数据值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全缓存管理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 今天头条号「JAVA前线」</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeRedisManager</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient RedisClient;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisLockManager redisLockManager;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDataSafe</span><span class="params">(String key, <span class="type">int</span> lockExpireSeconds, <span class="type">int</span> dataExpireSeconds, RedisBizCall bizCall, <span class="type">boolean</span> alwaysRetry)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">getLockSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redisClient.get(key);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/** 竞争分布式锁 **/</span></span><br><span class="line">                <span class="keyword">if</span> (getLockSuccess = redisLockManager.tryLock(key, lockExpireSeconds)) &#123;</span><br><span class="line">                    value = redisClient.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> value;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/** 查询数据库 **/</span></span><br><span class="line">                    value = bizCall.call();</span><br><span class="line">                    <span class="comment">/** 数据库无数据则返回**/</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/** 数据存入缓存 **/</span></span><br><span class="line">                    redisClient.setex(key, dataExpireSeconds, value);</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!alwaysRetry) &#123;</span><br><span class="line">                        logger.warn(<span class="string">&quot;竞争分布式锁失败,key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                    logger.warn(<span class="string">&quot;尝试重新获取数据,key=&#123;&#125;&quot;</span>, key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;getDistributeSafeError&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLockSuccess) &#123;</span><br><span class="line">                redisLockManager.unLock(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-分">4. 分</h2><p>我们首先看一个概念：读写比。互联网场景中一般是读多写少，例如浏览20次订单列表信息才会进行1次确认收货，此时读写比例就是20:1。面对读多写少这种情况我们可以做什么呢？</p><p>我们可以部署多台MySQL读库专门用来接收读请求，主库接收写请求并通过binlog实时同步的方式将数据同步至读库。MySQL官方即提供这种能力，进行简单配置即可。</p><p><img src="http://img.macky.cn/content/2022-03-18/5.png" alt="img"></p><p>那么客户端怎么知道访问读库还是写库呢？推荐使用ShardingSphere组件，通过配置将读写请求分别路由至读库或者写库。</p><h2 id="5-拆">5. 拆</h2><p>如果删除了历史数据并采用了其它存储介质，也用了读写分离，但是单表压力还是太大怎么办？这时我们只能拆分数据表，即把单库单表数据迁移到多库多张表中。</p><p>假设有一个电商数据库存放订单、商品、支付三张业务表。随着业务量越来越大，这三张业务数据表也越来越大，我们就以这个例子进行分析。</p><h3 id="5-1-垂直拆分">5.1. 垂直拆分</h3><p>垂直拆分就是按照业务拆分，我们将电商数据库拆分成三个库，订单库、商品库。支付库，订单表在订单库，商品表在商品库，支付表在支付库。这样每个库只需要存储本业务数据，物理隔离不会互相影响。</p><p><img src="http://img.macky.cn/content/2022-03-18/6.png" alt="img"></p><h3 id="5-2-水平拆分">5.2. 水平拆分</h3><p>按照垂直拆分方案，现在我们已经有三个库了，平稳运行了一段时间。但是随着业务增长，每个单库单表的数据量也越来越大，逐渐到达瓶颈。</p><p>这时我们就要对数据表进行水平拆分，所谓水平拆分就是根据某种规则将单库单表数据分散到多库多表，从而减小单库单表的压力。</p><p>水平拆分策略有很多方案，最重要的一点是选好ShardingKey，也就是按照哪一列进行拆分，怎么分取决于我们访问数据的方式。</p><h4 id="5-2-1-范围分片">5.2.1. 范围分片</h4><p>现在我们要对订单库进行水平拆分，我们选择的ShardingKey是订单创建时间，拆分策略如下：</p><p>(1) 拆分为四个数据库，分别存储每个季度的数据<br>(2) 每个库三张表，分别存储每个月的数据<br>上述方法优点是对范围查询比较友好，例如我们需要统计第一季度的相关数据，查询条件直接输入时间范围即可。</p><p><img src="http://img.macky.cn/content/2022-03-18/5.2.1.png" alt="img"></p><p>但是这个方案问题是容易产生热点数据。例如双11当天下单量特别大，就会导致11月这张表数据量特别大从而造成访问压力。</p><h4 id="5-2-2-查表分片">5.2.2. 查表分片</h4><p>查表法是根据一张路由表决定ShardingKey路由到哪一张表，每次路由时首先到路由表里查到分片信息，再到这个分片去取数据。</p><p>我们分析一个查表法实际案例。Redis官方在3.0版本之后提供了集群方案Redis Cluster，其中引入了哈希槽（slot）这个概念。</p><p>一个集群固定有16384个槽，在集群初始化时这些槽会平均分配到Redis集群节点上。每个key请求最终落到哪个槽计算公式是固定的：</p><blockquote><p>SLOT = CRC16(key) mod 16384</p></blockquote><p>那么问题来了：一个key请求过来怎么知道去哪台Redis节点获取数据？这就要用到查表法思想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 客户端连接任意一台Redis节点，假设随机访问到为节点A</span><br><span class="line">(2) 节点A根据key计算出slot值</span><br><span class="line">(3) 每个节点都维护着slot和节点映射关系表</span><br><span class="line">(4) 如果节点A查表发现该slot在本节点则直接返回数据给客户端</span><br><span class="line">(5) 如果节点A查表发现该slot不在本节点则返回给客户端一个重定向命令，告诉客户端应该去哪个节点上请求这个key的数据</span><br><span class="line">(6) 客户端再向正确节点发起连接请求</span><br></pre></td></tr></table></figure><p>查表法优点是可以灵活制定路由策略，如果我们发现有的分片已经成为热点则修改路由策略。缺点是多一次查询路由表操作增加耗时，而且路由表如果是单点也可能会有单点问题。</p><h4 id="5-2-3-哈希分片">5.2.3. 哈希分片</h4><p>现在比较流行的分片方法是哈希分片，相较于范围分片，哈希分片可以较为均匀将数据分散在数据库中。</p><p>我们现在将订单库拆分为4个库编号为[0,3]，每个库4张表编号为[0,3]，如下图如所示：</p><p><img src="http://img.macky.cn/content/2022-03-18/5.2.3.png" alt="img"></p><p>现在使用orderId作为ShardingKey，那么orderId=100的订单会保存在哪张表？我们来计算一下：由于是分库分表，首先确定路由到哪一个库，取模计算得到序号为0表示路由到db[0]</p><blockquote><p>db_index = 100 % 4 = 0</p></blockquote><p>库确定了接着在db[0]进行取模表路由</p><blockquote><p>table_index = 100 % 4 = 0</p></blockquote><p>最终这条数据应该路由至下表</p><blockquote><p>db[0]_table[0]</p></blockquote><p>最终计算结果如下图所示：</p><p><img src="http://img.macky.cn/content/2022-03-18/5.2.3-1.png" alt="img"></p><p>在实际开发中最终路由到哪张表，并不需要我们自己算，因为有许多开源框架就可以完成路由功能，例如ShardingSphere、TDDL等等。</p><h2 id="6-异">6. 异</h2><p>现在数据已经使用哈希分片方法完成了水平拆分，我们选择的ShardingKey是orderId。这时客户端需要查询orderId=111的数据，查询语句很简单如下：</p><blockquote><p>SELECT * FROM order WHERE orderId = 111</p></blockquote><p>这个语句没有问题，因为查询条件包含orderId，可以路由到具体的数据表。</p><p>现在如果业务想要查询用户维度的数据，希望查询userId=222的数据，现在问题来了：以下这个语句可以查出数据吗？</p><blockquote><p>SELECT * FROM order WHERE userId = 222</p></blockquote><p>答案是可以，但是需要扫描所有库的所有表，因为无法根据userId路由到具体某一张表，这样时间成本会非常高，这种场景怎么办呢？</p><p>这就要用到数据异构的思想。数据异构核心是用空间换时间，简单一句话就是一份数据按照不同业务需求保存多份，这样做是因为存储硬件成本不是很高，而互联网场景对响应速度要求很高。</p><p>对于上述需要使用userId进行查询的场景，我们完全可以新建库和表，数量和结构与订单库表完全一致，唯一不同点是ShardingKey改用userId，这样就可以使用userId查询了。</p><p>现在又引出一个新问题，业务不可能每次都将数据写入多个数据源，这样会带来性能问题和数据一致行为。怎么解决老库和新库数据同步问题？我们可以使用阿里开源的canal组件解决这个问题，看一张官网介绍canal架构图：</p><p><img src="http://img.macky.cn/content/2022-03-18/6-1.png" alt="img"></p><p>canal组件的主要用途是基于MySQL数据库增量日志解析，提供增量数据订阅和消费服务，工作原理如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) canal伪装成为MySQL slave模拟交互协议向master发送dump协议</span><br><span class="line">(2) master收到canal发送的dump请求，开始推送binlog给canal</span><br><span class="line">(3) canal解析binlog并发送到存储目的地，例如MySQL、Kafka、Elasticsearch</span><br></pre></td></tr></table></figure><p>canal组件下游可以对接很多其它数据源，这样给业务提供了更多选择。我们可以像上述实例中新建用户维度订单表，也可以将数据存在ES中提供运营检索能力等等。</p><h2 id="7-热">7. 热</h2><p>我们来分析这样一个场景：社交业务有一张用户关系表，主要记录谁关注了谁。其中有一个明星粉丝特别多，如果以userId作为分片，那么其所在分片数据量就会特别大。</p><p>不仅分片数据量特别大，而且可以预见这个分片访问频率也会非常高。此时数据量大并且访问频繁，很有可能造成系统压力。</p><h3 id="7-1-热点概念">7.1. 热点概念</h3><p>我们将访问行为称为热点行为，将访问对应的数据称为热点数据。我们通过实例来分析。</p><p>在电商双11活动中百分之八十的访问量会集中在百分之二十的商品上。用户刷新、添加购物车、下单被称为热点行为，相应商品数据就被称为热点数据。</p><p>在微博场景中大V发布一条消息会获得大量访问。用户对这条消息的浏览. 点赞、转发、评论被称为热点行为，这条消息数据被称为热点数据。</p><p>在秒杀场景中参与秒杀的商品会获得极大的瞬时访问量。用户对这个商品的频繁刷新、点击、下单被称为热点行为，参与秒杀的商品数据被称为热点数据。</p><p>我们必须将热点数据进行一些处理，使得热点访问更加流畅，更是为了保护系统免于崩溃。我们从发现热点数据、处理热点数据来展开分析。</p><h3 id="7-2-发现热点数据">7.2. 发现热点数据</h3><p>我们把发现热点数据分为两种方式：静态发现和动态发现。</p><p>静态发现：在开始秒杀活动之前，参与商家一定知道哪些商品参与秒杀，那么他们可以提前将这些商品报备告知平台。</p><p>在微博场景中，具有影响力的大V一般都很知名，网站运营同学可以提前知道。技术同学还可以通过分析历史数据找出TOP N数据。对于这些可以提前预判的数据，完全可以通过后台系统上报，这样系统可以提前做出预处理。</p><p>动态发现：有些商品可能并没有上报为热点商品，但是在实际销售中却非常抢手。在微博场景中，有些话题热度突然升温。这些数据成为事实上的热点数据。对于这些无法提前预判的数据，需要动态进行判断。</p><p>我们需要一个热点发现系统去主动发现热点数据。大体思路是首先异步收集访问日志，再统计单位时间内访问频次，当超过一定阈值时可以判断为热点数据。</p><h3 id="7-3-处理热点问题">7.3. 处理热点问题</h3><p>(1) 热点行为</p><p>热点行为可以采取高频检测方式，如果发现频率过高则进行限制。或者采用内存队列实现的生产者与消费者这种异步化方式，消费者根据能力处理请求。</p><p>(2) 热点数据</p><p>处理热点数据核心主要是根据业务形态来进行处理，我一般采用以下方案配合执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1) 选择合适ShardingKey进行分库分表</span><br><span class="line">(2) 异构数据至其它适合检索的数据源例如ES</span><br><span class="line">(3) 在MySQL之前设置缓存层</span><br><span class="line">(4) 尽量不在MySQL进行耗时操作（例如聚合）</span><br></pre></td></tr></table></figure><h2 id="8-文章总结">8. 文章总结</h2><p>本文我们详细介绍处理单表数据量过大的六字口诀：删、换、分、拆、异、热。这并不是意味这每次遇到单表数据量过大情况六种方案全部都要使用，例如拆分数据表成本确实比较高，会带来分布式事务、数据难以聚合等问题，如果不分表可以解决那么就不要分表，核心还是根据自身业务情况选择合适的方案。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
